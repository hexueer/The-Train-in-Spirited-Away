<!doctype html>

<!--HWK6 - Creative Scene for CS307
    Author: Yihui Liao and Ivy Ho
    Date: 04/10/2022

-->

<html>
    <head>
        <meta charset="utf-8">
        <title>Creative Scene</title>
        <style>
            * {
                margin: 0;
                padding: 0;
            }
        </style>

        <script src="https://cs.wellesley.edu/~cs307/threejs/libs/three-r95.all.js">
        "https://cs.wellesley.edu/~cs307/threejs/libs/three-r80.min.js"
        </script>
        <script src="https://cs.wellesley.edu/~cs307/threejs/libs/OrbitControls-r95.js">
        "https://cs.wellesley.edu/~cs307/threejs/libs/OrbitControls-r80.js"
        </script>
        <script src="https://cs.wellesley.edu/~cs307/threejs/libs/dat.gui-r95.js">
        "https://cs.wellesley.edu/~cs307/threejs/libs/dat.gui-r80.min.js"
        </script>
        <script src="https://cs.wellesley.edu/~cs307/threejs/libs/tw-sp21.js">
        "https://cs.wellesley.edu/~cs307/threejs/libs/tw-fa18.js"
        </script>
        <!-- Refer to https://sbcode.net/threejs/csg/ to understand the logic of ThreeBSP -->
        <script src="https://rawgit.com/Wilt/ThreeCSG/develop/ThreeCSG.js"></script>
    </head>
    <body>
        <script>
            // ====================================================================
            // set parameters for scene objects

            // object sizes
            var params = {
                groundDimension: 1000,
                plankHeight: .25,
				plankDepth: 5,
				plankWidth: 1,
				railZ: 1.5,
				railWidth: .25,
				railDepth: 3,
                
                // train car
                width: 20, // x
                height: 5, // y
                depth: 6, // z
                space: .25,
                
                wait: 3000, // wait time at stop in milliseconds
                hasStopped: false, // if stopped yet in the current cycle
                moving: true, // keeps track of whether train is in motion
            };

            var cameraParams = {
                    near: 1,
                    far: params.groundDimension,
                    fov: 100,
                    aspectRatio: window.innerWidth/window.innerHeight,
                    atX: params.groundDimension,
                    atY: 0,
                    atZ: 0,
                    eyeX: 0,
                    eyeY: 10,
                    eyeZ: 50,
                    upX: 0,
                    upY: 1,
                    upZ: 0
                  };

            // setupCamera() function creates and returns a camera with the desired parameters
            function setupCamera() {
                // set up an abbreviation 
                var cp = cameraParams;
                // create an initial camera with the desired shape
                var camera = new THREE.PerspectiveCamera(cp.fov, cp.aspectRatio, cp.near, cp.far);
                // set the camera location and orientation
                camera.position.set(cp.eyeX, cp.eyeY, cp.eyeZ);
                camera.up.set(cp.upX, cp.upY, cp.upZ);
                camera.lookAt(new THREE.Vector3(cp.atX, cp.atY, cp.atZ));
                return camera;
            }

            // ====================================================================
            // initialize environment

            let scene, camera, renderer, skyboxGeo, skybox, controls, train;

            function init() {
                scene = new THREE.Scene();
                camera = setupCamera();

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.domElement.id = "canvas";
                document.body.appendChild(renderer.domElement);

                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enabled = true;
                controls.maxDistance = params.groundDimension;

                skyboxGeo = new THREE.BoxGeometry(params.groundDimension, params.groundDimension, params.groundDimension);
                skybox = new THREE.Mesh(skyboxGeo, skyMaterials);
                scene.add(skybox);

                window.addEventListener('resize', onWindowResize, false);

                remakeScene();
                animate();
            };
            
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            };

            // ====================================================================
            // load textures and make scene

            // prepare materials
            var materials;  
            var colorMaterials; 
            var skyMaterials;          
            TW.loadTextures(["materials/rock.jpeg", "materials/concrete.jpeg", "materials/wood.jpg", "materials/metal.jpg", 
                            "materials/water.jpeg", "materials/plank.jpeg", "materials/sky.jpg", "materials/floor.jpg", 
                            "materials/right.png", "materials/left.png", "materials/top.png", "materials/bottom.png", "materials/front.png", "materials/back.png"],
            function (textures) {
                adjustTexture(textures[0], 200, 2, false);
                adjustTexture(textures[1], 10, 3, false);
                adjustTexture(textures[2], 1, 1, false);
                adjustTexture(textures[3], 3, 1, false);
                adjustTexture(textures[4], 50, 50, false);
                adjustTexture(textures[5], 4, 1, false);
                adjustTexture(textures[6], 1, 1, false);
                adjustTexture(textures[7], 1, 1, false);


                materials = [new THREE.MeshPhongMaterial({color: 0xffffff,  // 0 rock
                                                        map: textures[0]}),
                            new THREE.MeshPhongMaterial({color: 0xffffff,   // 1 concrete
                                                        map: textures[1]}),
                            new THREE.MeshPhongMaterial({color: 0xffffff,   // 2 water
                                                        map: textures[4],
                                                        side: THREE.DoubleSide}), 
                            new THREE.MeshPhongMaterial({color: 0xffffff,   // 3 wood
                                                        map: textures[2]}),
                            new THREE.MeshPhongMaterial({color: 0xffffff,   // 4 metal
                                                        map: textures[3]}),   
                            new THREE.MeshPhongMaterial({color: 0xffffff,   // 5 red plank
                                                        map: textures[5]}),
                            new THREE.MeshPhongMaterial({color: 0xffffff,   // 6 sky
                                                        map: textures[6],
                                                        side: THREE.BackSide}),   
                            new THREE.MeshPhongMaterial({color: 0xffffff,   // 7 floor
                                                        map: textures[7],
                                                        side: THREE.DoubleSide}),                     
                            ];

                colorMaterials = [new THREE.MeshPhongMaterial({color: new THREE.Color(0xfcce8e), // 0 beige
                                                        specular: new THREE.Color("dimgray"),
                                                        shininess: 5,
                                                        side: THREE.DoubleSide}),
                                new THREE.MeshPhongMaterial({color: new THREE.Color(0x4395A0), // 1 blue
                                                        specular: new THREE.Color("dimgray"),
                                                        shininess: 5,
                                                        side: THREE.DoubleSide}),   
                                new THREE.MeshPhongMaterial({color: new THREE.Color(0x000000), // 2 black
                                                        specular: new THREE.Color("dimgray"),
                                                        shininess: 5,
                                                        side: THREE.DoubleSide}),
                                new THREE.MeshPhysicalMaterial({color: new THREE.Color(0xffffff), // 3 glass
                                                        side: THREE.DoubleSide,
                                                        transparent: true,
                                                        opacity: .4,
                                                        roughness: 0,
                                                        reflectivity: 5,
                                                        shininess: 30
                                                        }),   
                                new THREE.MeshPhongMaterial({color: new THREE.Color(0x730a00), // 4 red
                                                        side: THREE.DoubleSide}), 
                                new THREE.MeshPhongMaterial({color: new THREE.Color(0x2e201c), // 5 brown
                                                        side: THREE.DoubleSide}), 
                                ];

                skyMaterials = textures.slice(8,14).map(texture => {
                                return new THREE.MeshBasicMaterial({ map: texture, side: THREE.BackSide });
                            });

                init();
            });

            // ====================================================================
            // functions to create scene objects

            function adjustTexture(texture, repeatH, repeatV, mirror) {
                texture.repeat.set(repeatH,repeatV);
                texture.needsUpdate = true;
                if (mirror) {
                    texture.wrapS = THREE.MirroredRepeatWrapping;
                    texture.wrapT = THREE.MirroredRepeatWrapping;
                } else {
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                }
            }

            function makeGround() {
                var ground = new THREE.Object3D();

                // // blue plane for bottom of the sea
                // var plane1 = new THREE.PlaneGeometry(params.groundDimension, params.groundDimension);
                // var planeMesh1 = new THREE.Mesh(plane1, colorMaterials[1]);
                // planeMesh1.rotation.x = Math.PI/2;
                // ground.add(planeMesh1);

                // blue plane for top of the sea
                var plane2 = new THREE.PlaneGeometry(params.groundDimension, params.groundDimension);
                var planeMesh2 = new THREE.Mesh(plane2, materials[2]);
                planeMesh2.rotation.x = Math.PI/2;
                planeMesh2.position.y = .5;
                
                // enable transparency
                planeMesh2.material.transparent = true;
                // set opacity to 50%
                planeMesh2.material.opacity = 0.5; 
                ground.add(planeMesh2);

                // rock path
                var path = new THREE.PlaneGeometry(params.groundDimension, params.groundDimension/100);

                var pathMesh = new THREE.Mesh(path, materials[0]);
                pathMesh.position.y = 0.01;
                pathMesh.rotation.x = Math.PI/2;
                pathMesh.material.side = THREE.DoubleSide;

                ground.add(pathMesh);

                // train tracks
                var positionX = -200;
                for (let i = 0; i <= 200; i++ ){
                    var track = makeTracks();
                    track.position.x = positionX + params.railDepth/2;
                    positionX += params.railDepth/2;
                    ground.add(track);
                }
                
                return ground;
            }

            function makeTracks(){
                var track = new THREE.Object3D();
                
				var height = params.plankHeight;
				var depth = params.plankDepth;
				var width = params.plankWidth;
				var railZ = params.railZ;

				var plankGeom = new THREE.BoxGeometry(width,height,depth);
				var plankMesh = new THREE.Mesh(plankGeom, materials[3]);

				var rail1 = makeRail();
				var rail2 = makeRail();

				rail1.position.z = railZ;
				rail2.position.z = -railZ;

				track.add(plankMesh)
				track.add(rail1);
				track.add(rail2);

				return track;
            }

            function makeRail(){
				var width = params.railWidth;
				var height = params.plankHeight;
				var depth = params.railDepth;

				var railGeom = new THREE.BoxGeometry(width, height, depth);
				var railMesh = new THREE.Mesh(railGeom, materials[4]);

				railMesh.position.y = height;
				railMesh.rotation.y = Math.PI/2;

				return railMesh;
			}

            function makeTrainCarGeomLowerBevel(width, height, depth, offsetX, offsetY, offsetZ) {
       
                // main length of box car and beveled head
                var boxGeom = new THREE.BoxGeometry(width, height/2, depth);
                var triPrismGeom = new THREE.CylinderGeometry(height/2, height/2, depth, 3);
                var cubeCutter = new THREE.BoxGeometry(height, height*5, depth);

                // align them 
                boxGeom.translate(width/2 + offsetX, height/4 + offsetY, offsetZ);
                triPrismGeom.translate(width*0.975 + offsetX, offsetY, height/4 + offsetZ);
                triPrismGeom.rotateX(-Math.PI/2);
                triPrismGeom.scale(1,6,1);
                cubeCutter.translate(width + offsetX, height*3 + offsetY, + offsetZ);

                // use ThreeBSP to union geometries
                var bsp_boxGeom = new ThreeBSP(boxGeom);
                var bsp_triPrismGeom = new ThreeBSP(triPrismGeom);
                var bsp_cubeCutter = new ThreeBSP(cubeCutter);

                return bsp_boxGeom.union(bsp_triPrismGeom.subtract(bsp_cubeCutter));
            }

            function makeTrainCarGeomUpperBevel(width, height, depth, offsetX, offsetY, offsetZ) {
       
                // main length of box car and beveled head
                var boxGeom = new THREE.BoxGeometry(width, height/2, depth);
                var triPrismGeom = new THREE.CylinderGeometry(height/3, height/3, depth, 3);

                // align them 
                boxGeom.translate(width/2 + offsetX, height*0.75 + offsetY, offsetZ);
                triPrismGeom.translate(width + offsetX, offsetY, height/1.5 + offsetZ);
                triPrismGeom.rotateX(-Math.PI/2);

                // use ThreeBSP to union geometries
                var bsp_boxGeom = new ThreeBSP(boxGeom);
                var bsp_triPrismGeom = new ThreeBSP(triPrismGeom);

                return bsp_boxGeom.union(bsp_triPrismGeom);
            }

            // takes a train car BSP geometry and adds windows but subtracting boxes from the car
            function addWindowHoles(bspGeom, width, height) {
                // cut out square windows
                var windowGeom = new THREE.BoxGeometry(height/4, height/4, height*1.5);
                windowGeom.translate( -0.65, height/1.35, 0 );

                var bsp_window;
                // cut out all the windows
                for (let i = 0; i < 13; i++) {
                    windowGeom.translate( 1.5, 0, 0 );
                    bsp_window = new ThreeBSP(windowGeom);
                    bspGeom = bspGeom.subtract(bsp_window);
                }

                // cut out triangle windows
                windowGeom = new THREE.ConeGeometry(height/6, height/3, 8, 1, false, 0, Math.PI); // half a cone has the silhouette of a triangle
                var geomCloser = new THREE.BoxGeometry(height/4, height/4, height/4);
                windowGeom.translate( width, height/1.35, params.depth/2 );
                geomCloser.translate( width+height/12, height/1.35, params.depth/2 );
                bsp_window = new ThreeBSP(windowGeom);
                var bsp_geomCloser = new ThreeBSP(geomCloser);
                bspGeom = bspGeom.subtract(bsp_window.intersect(bsp_geomCloser));

                windowGeom.translate( 0, 0, -params.depth );
                geomCloser.translate( 0, 0, -params.depth );
                bsp_window = new ThreeBSP(windowGeom);
                bsp_geomCloser = new ThreeBSP(geomCloser);
                bspGeom = bspGeom.subtract(bsp_window.intersect(bsp_geomCloser));

                // cut out front windows
                var windowGeom = new THREE.BoxGeometry(height, height/4, params.depth/2.5);
                windowGeom.translate( width*1.01, height/1.35, params.depth*0.25 );
                bsp_window = new ThreeBSP(windowGeom);
                bspGeom = bspGeom.subtract(bsp_window);

                windowGeom.translate( 0, 0, -params.depth*0.5 );
                bsp_window = new ThreeBSP(windowGeom);
                bspGeom = bspGeom.subtract(bsp_window);

                return bspGeom;
            }

            // takes a geometry and material and returns the mesh
            // method of producing the mesh varies depending on whether the geometry is 
            // a regular THREE geometry or a ThreeBSP geometry (has been hollowed out)
            function makeMesh(bsp_geom, material) {
                var mesh = bsp_geom.toMesh();
                mesh.material = material;

                return mesh;
            }

            // makes two wheel holes for the train car in the shape of trapezoids
            function addWheelHoles(bsp_geom, width, height, depth) {
                // wheel hole is the shape of a trapezoid
                var trapezoidGeom = new THREE.CylinderGeometry( width/12-0.5, width/12, height*0.99, 4, 1 );
                trapezoidGeom.rotateY( Math.PI / 4 );
                trapezoidGeom.scale( 1, 1, depth );
                trapezoidGeom.translate(width/3, height/2.1, 0);

                // add first hole
                var bsp_trapezoid = new ThreeBSP(trapezoidGeom);
                bsp_geom = bsp_geom.subtract(bsp_trapezoid);

                // add second hole
                trapezoidGeom.translate(width/1.5, 0, 0);
                var bsp_trapezoid = new ThreeBSP(trapezoidGeom);
                bsp_geom = bsp_geom.subtract(bsp_trapezoid);

                return bsp_geom;
            }

            // add wheels to train car
            function makeWheels(radius, material) {
                var wheelSet = new THREE.Object3D();

                // left wheel
                var wheelGeom = new THREE.TorusGeometry( radius, radius/1.5, 16, 100 );
                var wheelMesh = new THREE.Mesh(wheelGeom, material);
                wheelMesh.position.x = -radius*1.7;
                wheelSet.add(wheelMesh);

                // right wheel
                var wheelMesh = new THREE.Mesh(wheelGeom, material);
                wheelMesh.position.x = radius*1.7;
                wheelSet.add(wheelMesh);

                return wheelSet;
            }
            
            function makeTrainCarShape(width, height, depth, material, hollow){
                var shapeGeom = makeTrainCarGeom(width, height, depth, 0, 0, 0);

                if (hollow) {
                    var shapeInsideGeom = makeTrainCarGeom(width, height, depth-0.3, 0.1, 0, 0);
                    shapeGeom = shapeGeom.subtract(shapeInsideGeom);  // remove inside of train
                    // shapeGeom = addWheelHoles(shapeGeom, width, height, depth); // make wheel holes
                }

                var shapeMesh = makeMesh(shapeGeom, material);

                return shapeMesh;
            }

            function makeInterior(width, height, depth, material){
                
                // make train car body with holes for windows
                var carGeomLower = makeTrainCarGeomLowerBevel(width, height, depth, 0, 0, 0);
                var carGeomUpper = makeTrainCarGeomUpperBevel(width, height, depth, 0, 0, 0);
                var carGeom = carGeomLower.union(carGeomUpper);

                carGeom = addWindowHoles(carGeom, width, height);
                var carInsideGeom = makeTrainCarGeomLowerBevel(width-0.3, height, depth-0.1, 0.1, 0, 0).union(makeTrainCarGeomUpperBevel(width-0.3, height, depth-0.5, 0.1, 0, 0));
                carGeom = carGeom.subtract(carInsideGeom);  // remove inside of train
                var carMesh = makeMesh(carGeom, material);

                return carMesh;
            }

            function makeTrainCar(width, height, depth, material) {
                var car = new THREE.Object3D();
                
                // make train car body with holes for windows
                var carGeomLower = makeTrainCarGeomLowerBevel(width, height, depth, 0, 0, 0);
                var carGeomUpper = makeTrainCarGeomUpperBevel(width, height, depth, 0, 0, 0);
                var carGeom = carGeomLower.union(carGeomUpper);

                carGeom = addWindowHoles(carGeom, width, height);
                var carInsideGeom = makeTrainCarGeomLowerBevel(width-0.3, height, depth-0.1, 0.1, 0, 0).union(makeTrainCarGeomUpperBevel(width-0.3, height, depth-0.5, 0.1, 0, 0));
                carGeom = carGeom.subtract(carInsideGeom);  // remove inside of train
                var carMesh = makeMesh(carGeom, material);
                car.add(carMesh);

                // add red planking to the side of the train car
                var plankingGeom = makeTrainCarGeomLowerBevel(width+0.25, height, depth+0.15, 0, 0, 0);
                var plankingInsideGeom = makeTrainCarGeomLowerBevel(width, height, depth-0.15, 0.1, 0, 0);
                plankingGeom = plankingGeom.subtract(plankingInsideGeom);  // remove inside of plank prism
                var planking = makeMesh(plankingGeom, materials[5]);
                planking.position.x = -0.1;
                car.add(planking);

                // add train bottom
                var bottomGeom = new THREE.BoxGeometry(width*1.1, height/10, depth);
                bottomGeom.translate(width*0.55, height/20, 0);
                var bsp_bottom = addWheelHoles(new ThreeBSP(bottomGeom), width, height/10, depth);
                var bottom = makeMesh(bsp_bottom, colorMaterials[4]);
                bottom.position.y = -height/10;
                car.add(bottom);

                // add four wheel sets
                var wheelSet1 = makeWheels(height/15, colorMaterials[2]);
                wheelSet1.position.set(width/3, -height/12, depth/2-height/15);
                car.add(wheelSet1);
                var wheelSet2 = makeWheels(height/15, colorMaterials[2]);
                wheelSet2.position.set(width, -height/12, depth/2-height/15);
                car.add(wheelSet2);
                var wheelSet3 = makeWheels(height/15, colorMaterials[2]);
                wheelSet3.position.set(width/3, -height/12, -(depth/2-height/15));
                car.add(wheelSet3);
                var wheelSet4 = makeWheels(height/15, colorMaterials[2]);
                wheelSet4.position.set(width, -height/12, -(depth/2-height/15));
                car.add(wheelSet4);

                // add train top
                var topGeom = new THREE.BoxGeometry(width*1.01, height/10, depth);
                var top = new THREE.Mesh(topGeom, colorMaterials[4]);
                top.position.set(width/2, height*1.05, 0);
                car.add(top);

                // add "glass" to windows
                var windowGeom = makeTrainCarGeomUpperBevel(width-0.1, height, depth - 0.1, 0, 0, 0);
                var windowInsideGeom = makeTrainCarGeomUpperBevel(width-0.3, height, depth - 0.4, 0.1, 0, 0);
                windowGeom = windowGeom.subtract(windowInsideGeom); // remove inside of glass prism
                var window = makeMesh(windowGeom, colorMaterials[3]);
                car.add(window);

                // wood
                var interior = makeInterior(width - 0.2, height, depth - 0.2, colorMaterials[5]);
                interior.position.x = .1;
                car.add(interior);

                // add cylinders on top to decorate
                var smallCyl1 = makeTrainTopCylinder(1.5, .5, colorMaterials[4]);
                var smallCyl2 = makeTrainTopCylinder(1.5, .5, colorMaterials[4]);
                var longCyl = makeTrainTopCylinderLong(2, 1.5, .5, colorMaterials[4]);
                smallCyl1.position.set(width*0.85, height + 0.5, 0); // front side of car
                smallCyl2.position.set(width*0.15, height + 0.5, 0); // back side of car
                longCyl.position.set(width*0.5, height + 0.5, 0); // center of train car x-wise
                car.add(smallCyl1);
                car.add(smallCyl2);
                car.add(longCyl);

                // add train headlight with light beam
                var spotlight = makeSpotlight(.5, 1, 1, 1, colorMaterials[0], colorMaterials[4], 1);
                spotlight.position.set(width, height, 0);
                var light = new THREE.SpotLight(0xffffff, 1, 0, TW.degrees2radians(20), 0, 1);
                light.position.set(width, height, 0);
                light.target.position.set(30, 0, 0);
                car.add(spotlight);
                car.add(light);
                car.add(light.target);

                // add flooring to car
                var floor = makeFloor(width*1.08, depth);
                floor.position.set(width*0.54, height/15, 0);
                car.add(floor);

                return car;
            }

            function makeTrain(){
                var train = new THREE.Object3D();

                var space = params.space;
                // make two base car geometries
                var car1 = makeTrainCar(params.width, params.height, params.depth, colorMaterials[0]);
                var car2 = makeTrainCar(params.width, params.height, params.depth, colorMaterials[0]);
                car1.position.x = space;
                car2.position.x = -space;
                car2.rotation.y = Math.PI;

                train.add(car1);
                train.add(car2);

                var connector = addConnector();

                train.add(connector);

                return train;
            }

            function makeSign(radius, height){
                var sign = new THREE.Object3D();

                var barGeom = new THREE.CylinderGeometry(radius, radius, height, 32);
                var barMesh = new THREE.Mesh(barGeom, materials[4]);

                var plateGeom = new THREE.CylinderGeometry(radius * 10, radius * 10, radius + .2, 32);
                var plateMesh = new THREE.Mesh(plateGeom, colorMaterials[4]);

                plateMesh.rotation.x = Math.PI/2;
                plateMesh.position.y = height/2;

                sign.add(barMesh);
                sign.add(plateMesh);

                return sign; 

            }

            function makeFloor(width, height){
                
                var floor = new THREE.Object3D();

                var planeGeom = new THREE.PlaneGeometry(width, height);
                var planeMesh = new THREE.Mesh(planeGeom, materials[7]);

                planeMesh.rotation.x = Math.PI/2;

                floor.add(planeMesh);

                return floor;
            }

            function makeSpotlight(radius, width, height, depth, coneMaterial, boxMaterial, side){

                var spotlight = new THREE.Object3D();

                var boxGeom = new THREE.BoxGeometry(width, height, depth);
                var boxMesh = new THREE.Mesh(boxGeom, boxMaterial);

                boxMesh.position.y = height/2;

                var coneGeom = new THREE.ConeGeometry(radius, width, 64, 1, true);
                var coneMesh = new THREE.Mesh(coneGeom, coneMaterial);

                coneMesh.rotation.z = side * Math.PI/2;
                coneMesh.position.x = side * .5;
                coneMesh.position.y = width/2;

                var sphereGeom = new THREE.SphereGeometry(radius/2, 32, 16 );
                var sphereMesh = new THREE.Mesh(sphereGeom, colorMaterials[3]);

                sphereMesh.position.x = side * .5;
                sphereMesh.position.y = width/2;
                
                spotlight.add(boxMesh);
                spotlight.add(coneMesh);
                spotlight.add(sphereMesh);

                return spotlight;
            }

            function makeTrainTopCylinder(radius, height, material){

                var cylinder = new THREE.Object3D();
                
                var cylinderGeom = new THREE.CylinderGeometry(radius, radius, height, 20);
                var cylinderMesh = new THREE.Mesh(cylinderGeom, material);
                cylinderMesh.position.y = height/2;
                cylinder.add(cylinderMesh);

                return cylinder;
            }

            function makeTrainTopCylinderLong(width, radius, height, material){

                var cylinderLong = new THREE.Object3D();

                var cylinder1 = makeTrainTopCylinder(radius, height, material);
                var cylinder2 = makeTrainTopCylinder(radius, height, material);

                cylinder1.position.x = width/2;
                cylinder2.position.x = -width/2;

                var boxGeom = new THREE.BoxGeometry(width, height, radius * 2);
                var boxMesh = new THREE.Mesh(boxGeom, material);
                boxMesh.position.y = height/2;

                cylinderLong.add(boxMesh);
                cylinderLong.add(cylinder1);
                cylinderLong.add(cylinder2);

                return cylinderLong;
            }

            function makeWindowEnds(side){

                var window = new THREE.Object3D();

                var cylinderGeom = new THREE.CylinderGeometry(5, 5, 20, 32);
                // var cylinderGeom = 
            }

            function addConnector(){

                var connector = new THREE.Object3D();

                var space = params.space;
                var width = space * 2 - .1;
                var height = params.height - .5;
                var depth = params.depth - .5;

                var boxGeom = new THREE.BoxGeometry(width, height, depth);
                var boxMesh = new THREE.Mesh(boxGeom, colorMaterials[2]);
                boxMesh.position.y = height/2;

                connector.add(boxMesh);

                return connector;
            }


            // make train station platform
            function makePlatform() {
                // make plane size relative to ground size
                var dimension = params.groundDimension;
                var platHeight = 1.5;

                var platGeom = new THREE.CylinderGeometry( dimension/130, dimension/100, platHeight, 4, 1 );
                platGeom.rotateY( Math.PI / 4 );
                platGeom.scale( 6, 1, 1 );
                // var platGeom = new THREE.BoxGeometry(dimension/50, platHeight, dimension/200);
                var platMesh = new THREE.Mesh(platGeom, materials[1])
                platMesh.position.set(-10, platHeight*0.5, -params.plankDepth*2); // add a little extra on y so it doesn't glitch

                return platMesh;
            }

            // render the scene
            function remakeScene() {
                addLighting();

                var ground = makeGround();
                scene.add(ground);

                var plat = makePlatform();
                scene.add(plat);

                train = makeTrain();
                train.position.y = 1;
                train.position.x = -params.groundDimension/2;
                scene.add(train);

                var sign = makeSign(.1, 5);
                sign.position.set(-38, 3, -10);
                scene.add(sign);

                render();
            }
            // ====================================================================
            // make lights

            function addLighting() {
                // 55% intensity
                var ambLight = new THREE.AmbientLight(new THREE.Color("white"), 0.55);
                scene.add(ambLight);
                
                // directional light coming from slightly right, front, and up direction
                var dirLight = new THREE.DirectionalLight( TW.WHITE, 0.7 );
                dirLight.position.set( 0.7, 0.9, 1 );
                // dirLight.position.set(0, 5, 10);
                scene.add(dirLight);
            }
            
            // ====================================================================
            // animation 

            var animationState;

            function resetAnimationState() {
                animationState = {
                    rx: 1.2
                }
            }
            resetAnimationState();

            function pauseAnimation() {
                animationState.rx = 0;
                params.moving = false;
            }

            function increaseSpeed() {
                animationState.rx += .003;
            }

            function decreaseSpeed() {
                animationState.rx -= .00145;
            }

            function oneStep() {
                train.position.x += animationState.rx;

                if (params.moving) {
                    // restart train at left end
                    if (train.position.x >= params.groundDimension/2) {
                        train.position.x = -params.groundDimension/2;
                        params.hasStopped = false;
                        resetAnimationState();
                    }
                    // pause train at the platform
                    else if (train.position.x > -5) {
                        if (!params.hasStopped) {
                            params.hasStopped = true;
                            pauseAnimation();
                            setTimeout(() => { params.moving = true; }, params.wait); // restart animation after wait
                        } else {
                            increaseSpeed();
                        }
                    } else {
                        decreaseSpeed();
                    }
                }

                render();
            }

            function animate() {
                oneStep();
                renderer.render(scene, camera);
                requestAnimationFrame(animate);
            }

            function render() {
                renderer.render(scene, camera);
            }

            // ====================================================================

        </script>
    </body>
</html>