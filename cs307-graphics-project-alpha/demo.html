<!doctype html>

<!--HWK6 - Creative Scene for CS307
    Author: Yihui Liao and Ivy Ho
    Date: 04/10/2022

-->

<html>
    <head>
        <meta charset="utf-8">
        <title>Creative Scene</title>
        <style>
            * {
                margin: 0;
                padding: 0;
            }
        </style>

        <script src="https://cs.wellesley.edu/~cs307/threejs/libs/three-r95.all.js">
        "https://cs.wellesley.edu/~cs307/threejs/libs/three-r80.min.js"
        </script>
        <script src="https://cs.wellesley.edu/~cs307/threejs/libs/OrbitControls-r95.js">
        "https://cs.wellesley.edu/~cs307/threejs/libs/OrbitControls-r80.js"
        </script>
        <script src="https://cs.wellesley.edu/~cs307/threejs/libs/dat.gui-r95.js">
        "https://cs.wellesley.edu/~cs307/threejs/libs/dat.gui-r80.min.js"
        </script>
        <script src="https://cs.wellesley.edu/~cs307/threejs/libs/tw-sp21.js">
        "https://cs.wellesley.edu/~cs307/threejs/libs/tw-fa18.js"
        </script>
        <!-- Refer to https://sbcode.net/threejs/csg/ to understand the logic of ThreeBSP -->
        <script src="./threecsg.js"></script>  <!-- code from https://github.com/Wilt/ThreeCSG @Wilt, forked from chandlerprall -->
    </head>
    <body>
        <script>
            // ====================================================================
            // set parameters for scene objects

            // object sizes
            var params = {
                groundDimension: 1000,
                plankHeight: .25,
				plankDepth: 5,
				plankWidth: 1,
				railZ: 1.5,
				railWidth: .25,
				railDepth: 3,
                
                // train car
                width: 20, // x
                height: 5, // y
                depth: 5, // z
                space: .5,
                
                wait: 3000, // wait time at stop in milliseconds
                hasStopped: false, // if stopped yet in the current cycle
                moving: true, // keeps track of whether train is in motion
                insideTrain: false, // camera view should be inside train now
            };

            var cameraParams = {
                    near: 1,
                    far: params.groundDimension,
                    fov: 100,
                    aspectRatio: window.innerWidth/window.innerHeight,
                    atX: 0,
                    atY: 5,
                    atZ: 0,
                    eyeX: 0,
                    eyeY: 5,
                    eyeZ: 40,
                    upX: 0,
                    upY: 1,
                    upZ: 0
                  };

            // setupCamera() function creates and returns a camera with the desired parameters
            function setupCamera() {
                // set up an abbreviation 
                var cp = cameraParams;
                // create an initial camera with the desired shape
                var camera = new THREE.PerspectiveCamera(cp.fov, cp.aspectRatio, cp.near, cp.far);
                // set the camera location and orientation
                camera.position.set(cp.eyeX, cp.eyeY, cp.eyeZ);
                camera.up.set(cp.upX, cp.upY, cp.upZ);
                camera.lookAt(new THREE.Vector3(cp.atX, cp.atY, cp.atZ));
                return camera;
            }

            // ====================================================================
            // initialize environment

            let scene, camera, renderer, skyboxGeo, skybox, controls, train;
            // wheels need to be global to rotate
            let w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15, w16;
            let wheelList;

            function init() {
                scene = new THREE.Scene();
                camera = setupCamera();

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.domElement.id = "canvas";
                document.body.appendChild(renderer.domElement);

                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enabled = true;
                controls.maxDistance = params.groundDimension;

                skyboxGeo = new THREE.BoxGeometry(params.groundDimension, params.groundDimension, params.groundDimension);
                skybox = new THREE.Mesh(skyboxGeo, skyMaterials);
                scene.add(skybox);

                window.addEventListener('resize', onWindowResize, false);

                remakeScene();
                animate();
            };
            
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            };

            // ====================================================================
            // load textures and make scene

            // prepare materials
            var materials;  
            var colorMaterials; 
            var skyMaterials;          
            TW.loadTextures(["materials/rock.jpeg", "materials/concrete.jpeg", "materials/wood.jpg", "materials/metal.jpg", 
                            "materials/water.jpeg", "materials/plank.jpeg", "materials/sky.jpg", "materials/floor.jpg", 
                            "materials/right.png", "materials/left.png", "materials/top.png", "materials/bottom.png", "materials/front.png", "materials/back.png"],
            function (textures) {
                adjustTexture(textures[0], 200, 2, false);
                adjustTexture(textures[1], 10, 3, false);
                adjustTexture(textures[2], 1, 1, false);
                adjustTexture(textures[3], 3, 1, false);
                adjustTexture(textures[4], 50, 50, false);
                adjustTexture(textures[5], 4, 1, false);
                adjustTexture(textures[6], 1, 1, false);
                adjustTexture(textures[7], 1, 1, false);


                materials = [new THREE.MeshPhongMaterial({color: 0xffffff,  // 0 rock
                                                        map: textures[0]}),
                            new THREE.MeshPhongMaterial({color: 0xffffff,   // 1 concrete
                                                        map: textures[1]}),
                            new THREE.MeshPhongMaterial({color: 0xffffff,   // 2 water
                                                        map: textures[4],
                                                        side: THREE.DoubleSide}), 
                            new THREE.MeshPhongMaterial({color: 0xffffff,   // 3 wood
                                                        map: textures[2]}),
                            new THREE.MeshPhongMaterial({color: 0xffffff,   // 4 metal
                                                        map: textures[3]}),   
                            new THREE.MeshPhongMaterial({color: 0xffffff,   // 5 red plank
                                                        map: textures[5]}),
                            new THREE.MeshPhongMaterial({color: 0xffffff,   // 6 sky
                                                        map: textures[6],
                                                        side: THREE.BackSide}),   
                            new THREE.MeshPhongMaterial({color: 0xffffff,   // 7 floor
                                                        map: textures[7],
                                                        side: THREE.DoubleSide}),                     
                            ];

                colorMaterials = [new THREE.MeshPhongMaterial({color: new THREE.Color(0xfcce8e), // 0 beige
                                                        specular: new THREE.Color("dimgray"),
                                                        shininess: 5,
                                                        side: THREE.DoubleSide}),
                                new THREE.MeshPhongMaterial({color: new THREE.Color(0x4395A0), // 1 blue
                                                        specular: new THREE.Color("dimgray"),
                                                        shininess: 5,
                                                        side: THREE.DoubleSide}),   
                                new THREE.MeshPhongMaterial({color: new THREE.Color(0x000000), // 2 black
                                                        specular: new THREE.Color("dimgray"),
                                                        shininess: 5,
                                                        side: THREE.DoubleSide}),
                                new THREE.MeshPhysicalMaterial({color: new THREE.Color(0xffffff), // 3 glass
                                                        side: THREE.DoubleSide,
                                                        transparent: true,
                                                        opacity: .4,
                                                        roughness: 0,
                                                        reflectivity: 5
                                                        }),   
                                new THREE.MeshPhongMaterial({color: new THREE.Color(0x730a00), // 4 red
                                                        side: THREE.DoubleSide}), 
                                new THREE.MeshPhongMaterial({color: new THREE.Color(0x2e201c), // 5 brown
                                                        side: THREE.DoubleSide}), 
                                new THREE.MeshPhongMaterial({color: new THREE.Color(0xffffff), // 6 white
                                                        side: THREE.DoubleSide}), 
                                ];

                skyMaterials = textures.slice(8,14).map(texture => {
                                return new THREE.MeshBasicMaterial({ map: texture, side: THREE.BackSide });
                            });

                init();
                TW.mainInit(renderer,scene);
                TW.setKeyboardCallback('a', showTrainSideView, "train side view", false);
                TW.setKeyboardCallback('s', followTrainSideView, "follow train side view", false);
                TW.setKeyboardCallback('d', showInsideTrain, "inside train", false);
            });

            // ====================================================================
            // functions to create scene objects

            function adjustTexture(texture, repeatH, repeatV, mirror) {
                texture.repeat.set(repeatH,repeatV);
                texture.needsUpdate = true;
                if (mirror) {
                    texture.wrapS = THREE.MirroredRepeatWrapping;
                    texture.wrapT = THREE.MirroredRepeatWrapping;
                } else {
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                }
            }

            function makeGround() {
                var ground = new THREE.Object3D();

                // // blue plane for bottom of the sea
                // var plane1 = new THREE.PlaneGeometry(params.groundDimension, params.groundDimension);
                // var planeMesh1 = new THREE.Mesh(plane1, colorMaterials[1]);
                // planeMesh1.rotation.x = Math.PI/2;
                // ground.add(planeMesh1);

                // blue plane for top of the sea
                var plane2 = new THREE.PlaneGeometry(params.groundDimension, params.groundDimension);
                var planeMesh2 = new THREE.Mesh(plane2, materials[2]);
                planeMesh2.rotation.x = Math.PI/2;
                planeMesh2.position.y = .5;
                
                // enable transparency
                planeMesh2.material.transparent = true;
                // set opacity to 50%
                planeMesh2.material.opacity = 0.5; 
                ground.add(planeMesh2);

                // rock path
                var path = new THREE.PlaneGeometry(params.groundDimension, params.groundDimension/100);

                var pathMesh = new THREE.Mesh(path, materials[0]);
                pathMesh.position.y = 0.01;
                pathMesh.rotation.x = Math.PI/2;
                pathMesh.material.side = THREE.DoubleSide;

                ground.add(pathMesh);

                // train tracks
                var positionX = -200;
                for (let i = 0; i <= 200; i++ ){
                    var track = makeTracks();
                    track.position.x = positionX + params.railDepth/2;
                    positionX += params.railDepth/2;
                    ground.add(track);
                }
                
                return ground;
            }

            function makeTracks(){
                var track = new THREE.Object3D();
                
				var height = params.plankHeight;
				var depth = params.plankDepth;
				var width = params.plankWidth;
				var railZ = params.railZ;

				var plankGeom = new THREE.BoxGeometry(width,height,depth);
				var plankMesh = new THREE.Mesh(plankGeom, materials[3]);

				var rail1 = makeRail();
				var rail2 = makeRail();

				rail1.position.z = railZ;
				rail2.position.z = -railZ;

				track.add(plankMesh)
				track.add(rail1);
				track.add(rail2);

				return track;
            }

            function makeRail(){
				var width = params.railWidth;
				var height = params.plankHeight;
				var depth = params.railDepth;

				var railGeom = new THREE.BoxGeometry(width, height, depth);
				var railMesh = new THREE.Mesh(railGeom, materials[4]);

				railMesh.position.y = height;
				railMesh.rotation.y = Math.PI/2;

				return railMesh;
			}

            function makeTrainCarGeomLowerBevel(width, height, depth, offsetX, offsetY, offsetZ) {
       
                // main length of box car and beveled head
                var boxGeom = new THREE.BoxGeometry(width, height/2, depth);
                var triPrismGeom = new THREE.CylinderGeometry(height/2, height/2, depth, 3);
                var cubeCutter = new THREE.BoxGeometry(height, height*5, depth);

                // align them 
                boxGeom.translate(width/2 + offsetX, height/4 + offsetY, offsetZ);
                triPrismGeom.translate(width*0.975 + offsetX, offsetY, height/4 + offsetZ);
                triPrismGeom.rotateX(-Math.PI/2);
                triPrismGeom.scale(1,6,1);
                cubeCutter.translate(width + offsetX, height*3 + offsetY, + offsetZ);

                // use ThreeBSP to union geometries
                var bsp_boxGeom = new ThreeBSP(boxGeom);
                var bsp_triPrismGeom = new ThreeBSP(triPrismGeom);
                var bsp_cubeCutter = new ThreeBSP(cubeCutter);

                return bsp_boxGeom.union(bsp_triPrismGeom.subtract(bsp_cubeCutter));
            }

            function makeTrainCarGeomUpperBevel(width, height, depth, offsetX, offsetY, offsetZ) {
       
                // main length of box car and beveled head
                var boxGeom = new THREE.BoxGeometry(width, height/2, depth);
                var triPrismGeom = new THREE.CylinderGeometry(height/3, height/3, depth, 3);

                // align them 
                boxGeom.translate(width/2 + offsetX, height*0.75 + offsetY, offsetZ);
                triPrismGeom.translate(width + offsetX, offsetY, height/1.5 + offsetZ);
                triPrismGeom.rotateX(-Math.PI/2);

                // use ThreeBSP to union geometries
                var bsp_boxGeom = new ThreeBSP(boxGeom);
                var bsp_triPrismGeom = new ThreeBSP(triPrismGeom);

                return bsp_boxGeom.union(bsp_triPrismGeom);
            }

            function addDoorHoles(bspGeom, width, height, offsetX) {
                var doorGeom = new THREE.BoxGeometry(height/3.6, height*0.8, height*1.5);
                doorGeom.translate( 1.15 - offsetX, height/5, 0 );

                var bsp_door = new ThreeBSP(doorGeom);
                bspGeom = bspGeom.subtract(bsp_door);

                doorGeom.translate(width*0.787, 0, 0);
                var bsp_door = new ThreeBSP(doorGeom);
                bspGeom = bspGeom.subtract(bsp_door);

                return bspGeom;
            }

            // prism geometry inspired by Alexan0208 @http://alexan0308.github.io/threejs/examples/#webgl_geometry_PrismGeometry
            PrismGeometry = function ( vertices, height ) {

                var Shape = new THREE.Shape();

                ( function f( ctx ) {

                    ctx.moveTo( vertices[0].x, vertices[0].y );
                    for (var i=1; i < vertices.length; i++) {
                        ctx.lineTo( vertices[i].x, vertices[i].y );
                    }
                    ctx.lineTo( vertices[0].x, vertices[0].y );

                } )( Shape );

                var settings = { };
                settings.amount = height;
                settings.bevelEnabled = false;
                THREE.ExtrudeGeometry.call( this, Shape, settings );

            };
            PrismGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );

            // takes a train car BSP geometry and adds windows but subtracting boxes from the car
            function addWindowHoles(bspGeom, width, height) {
                // cut out square windows
                var windowGeom = new THREE.BoxGeometry(height/3.6, height/3.6, height*1.5);
                windowGeom.translate( -0.62, height/1.42, 0 );

                var bsp_window;
                // cut out all the windows
                for (let i = 0; i < 11; i++) {
                    windowGeom.translate( 1.75, 0, 0 );
                    bsp_window = new ThreeBSP(windowGeom);
                    bspGeom = bspGeom.subtract(bsp_window);
                }

                var A = new THREE.Vector2( 0, 0 );
                var B = new THREE.Vector2( 0, height/3.6 );
                var C = new THREE.Vector2( 0.2, height/3.6 );
                var D = new THREE.Vector2( height/5, 0 );
             
                var windowGeom = new PrismGeometry( [ A, B, C, D ], height*1.5 );
                windowGeom.translate( width*0.99, height*0.565, -height*0.75 );

                bsp_window = new ThreeBSP(windowGeom);
                bspGeom = bspGeom.subtract(bsp_window);

                // cut out front windows
                var windowGeom = new THREE.BoxGeometry(height, height/3, params.depth/2.5);
                windowGeom.translate( width*1.01, height/1.4, params.depth*0.25 );
                bsp_window = new ThreeBSP(windowGeom);
                bspGeom = bspGeom.subtract(bsp_window);

                windowGeom.translate( 0, 0, -params.depth*0.5 );
                bsp_window = new ThreeBSP(windowGeom);
                bspGeom = bspGeom.subtract(bsp_window);

                return bspGeom;
            }

            // takes a geometry and material and returns the mesh
            // method of producing the mesh varies depending on whether the geometry is 
            // a regular THREE geometry or a ThreeBSP geometry (has been hollowed out)
            function makeMesh(bsp_geom, material) {
                var mesh = bsp_geom.toMesh();
                mesh.material = material;

                return mesh;
            }

            // makes two wheel holes for the train car in the shape of trapezoids
            function addWheelHoles(bsp_geom, width, height, depth) {
                // wheel hole is the shape of a trapezoid
                var trapezoidGeom = new THREE.CylinderGeometry( width/12-0.5, width/12, height*0.99, 4, 1 );
                trapezoidGeom.rotateY( Math.PI / 4 );
                trapezoidGeom.scale( 1, 1, depth );
                trapezoidGeom.translate(width/3, height/2.1, 0);

                // add first hole
                var bsp_trapezoid = new ThreeBSP(trapezoidGeom);
                bsp_geom = bsp_geom.subtract(bsp_trapezoid);

                // add second hole
                trapezoidGeom.translate(width/1.5, 0, 0);
                var bsp_trapezoid = new ThreeBSP(trapezoidGeom);
                bsp_geom = bsp_geom.subtract(bsp_trapezoid);

                return bsp_geom;
            }

            // add wheels to train car
            function makeWheels(width, height, depth, material) {
                var wheelSet = new THREE.Object3D();
                var space = height/15*1.7; // space between two wheels in the same hole
                var displacement = params.space; // displaced 
                // use same wheel shape for every wheel
                var wheelGeom = new THREE.TorusGeometry( height/15, height/22.5, 16, 100 );
                wheelGeom.scale(1,1.15,1);

                // right train
                // 1st wheel
                w1 = new THREE.Mesh(wheelGeom, material);
                w1.position.set(width/3 - space + displacement, -height/12, depth/2-height/15)
                wheelSet.add(w1);
                // adjacent wheel
                w2 = new THREE.Mesh(wheelGeom, material);
                w2.position.set(width/3 + space + displacement, -height/12, depth/2-height/15)
                wheelSet.add(w2);

                // 3rd wheel
                w3 = new THREE.Mesh(wheelGeom, material);
                w3.position.set(width - space + displacement, -height/12, depth/2-height/15)
                wheelSet.add(w3);
                // adjacent wheel
                w4 = new THREE.Mesh(wheelGeom, material);
                w4.position.set(width + space + displacement, -height/12, depth/2-height/15)
                wheelSet.add(w4);

                // 5th wheel
                w5 = new THREE.Mesh(wheelGeom, material);
                w5.position.set(width/3 - space + displacement, -height/12, -(depth/2-height/15))
                wheelSet.add(w5);
                // adjacent wheel
                w6 = new THREE.Mesh(wheelGeom, material);
                w6.position.set(width/3 + space + displacement, -height/12, -(depth/2-height/15))
                wheelSet.add(w6);

                // 7th wheel
                w7 = new THREE.Mesh(wheelGeom, material);
                w7.position.set(width - space + displacement, -height/12, -(depth/2-height/15))
                wheelSet.add(w7);
                // adjacent wheel
                w8 = new THREE.Mesh(wheelGeom, material);
                w8.position.set(width + space + displacement, -height/12, -(depth/2-height/15))
                wheelSet.add(w8);

                // left train
                // 9th wheel
                w9 = new THREE.Mesh(wheelGeom, material);
                w9.position.set(-(width/3 - space) - displacement, -height/12, depth/2-height/15)
                wheelSet.add(w9);
                // adjacent wheel
                w10 = new THREE.Mesh(wheelGeom, material);
                w10.position.set(-(width/3 + space) - displacement, -height/12, depth/2-height/15)
                wheelSet.add(w10);

                // 11th wheel
                w11 = new THREE.Mesh(wheelGeom, material);
                w11.position.set(-(width - space) - displacement, -height/12, depth/2-height/15)
                wheelSet.add(w11);
                // adjacent wheel
                w12 = new THREE.Mesh(wheelGeom, material);
                w12.position.set(-(width + space) - displacement, -height/12, depth/2-height/15)
                wheelSet.add(w12);

                // 13th wheel
                w13 = new THREE.Mesh(wheelGeom, material);
                w13.position.set(-(width/3 - space) - displacement, -height/12, -(depth/2-height/15))
                wheelSet.add(w13);
                // adjacent wheel
                w14 = new THREE.Mesh(wheelGeom, material);
                w14.position.set(-(width/3 + space) - displacement, -height/12, -(depth/2-height/15))
                wheelSet.add(w14);

                // 15th wheel
                w15 = new THREE.Mesh(wheelGeom, material);
                w15.position.set(-(width - space) - displacement, -height/12, -(depth/2-height/15))
                wheelSet.add(w15);
                // adjacent wheel
                w16 = new THREE.Mesh(wheelGeom, material);
                w16.position.set(-(width + space) - displacement, -height/12, -(depth/2-height/15))
                wheelSet.add(w16);

                wheelList = [w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15, w16];
                return wheelSet;
            }

            function makeInterior(width, height, depth, material){
                
                // make train car body with holes for windows
                var carGeomLower = makeTrainCarGeomLowerBevel(width-0.1, height, depth, 0, 0, 0);
                var carGeomUpper = makeTrainCarGeomUpperBevel(width-0.1, height, depth, 0, 0, 0);
                var carGeom = carGeomLower.union(carGeomUpper);

                carGeom = addWindowHoles(carGeom, width, height);
                carGeom = addDoorHoles(carGeom, width, height, .01);
                var carInsideGeom = makeTrainCarGeomLowerBevel(width-0.4, height, depth-0.15, 0.15, 0, 0).union(makeTrainCarGeomUpperBevel(width-0.4, height, depth-0.15, 0.15, 0, 0));
                carGeom = carGeom.subtract(carInsideGeom);  // remove inside of train
                var carMesh = makeMesh(carGeom, material);

                return carMesh;
            }

            // code from Paul West @https://jsfiddle.net/prisoner849/303kdmnd/
            function createBoxWithRoundedEdges( width, height, depth, radius0, smoothness ) {
                let shape = new THREE.Shape();
                let eps = 0.00001;
                let radius = radius0 - eps;
                shape.absarc( eps, eps, eps, -Math.PI / 2, -Math.PI, true );
                shape.absarc( eps, height -  radius * 2, eps, Math.PI, Math.PI / 2, true );
                shape.absarc( width - radius * 2, height -  radius * 2, eps, Math.PI / 2, 0, true );
                shape.absarc( width - radius * 2, eps, eps, 0, -Math.PI / 2, true );
                let geometry = new THREE.ExtrudeBufferGeometry( shape, {
                    amount: depth - radius0 * 2,
                    bevelEnabled: true,
                    bevelSegments: smoothness * 2,
                    steps: 1,
                    bevelSize: radius,
                    bevelThickness: radius0,
                    curveSegments: smoothness
                });
                
                geometry.center();
                
                return geometry;
            }

            function makeTrainCar(width, height, depth, material) {
                var car = new THREE.Object3D();
                
                // make train car body with holes for windows
                var carGeomLower = makeTrainCarGeomLowerBevel(width, height, depth, 0, 0, 0);
                var carGeomUpper = makeTrainCarGeomUpperBevel(width, height, depth, 0, 0, 0);
                var carGeom = carGeomLower.union(carGeomUpper);

                carGeom = addWindowHoles(carGeom, width, height);
                carGeom = addDoorHoles(carGeom, width, height, 0);
                var carInsideGeom = makeTrainCarGeomLowerBevel(width-0.2, height, depth-0.1, 0.1, 0, 0).union(makeTrainCarGeomUpperBevel(width-0.2, height, depth-0.1, 0.1, 0, 0));
                carGeom = carGeom.subtract(carInsideGeom);  // remove inside of train
                var carMesh = makeMesh(carGeom, material);
                car.add(carMesh);

                // add red planking to the side of the train car
                var plankingGeom = makeTrainCarGeomLowerBevel(width+0.25, height, depth+0.15, 0, 0, 0);
                plankingGeom = addDoorHoles(plankingGeom, width, height, -0.1);
                var plankingInsideGeom = makeTrainCarGeomLowerBevel(width, height, depth-0.15, 0.1, 0, 0);
                plankingGeom = plankingGeom.subtract(plankingInsideGeom);  // remove inside of plank prism
                var planking = makeMesh(plankingGeom, materials[5]);
                planking.position.x = -0.1;
                car.add(planking);

                // add train bottom
                var bottomGeom = new THREE.BoxGeometry(width*1.1, height/10, depth);
                bottomGeom.translate(width*0.55, height/10, 0);
                var bsp_bottom = addWheelHoles(new ThreeBSP(bottomGeom), width, height/10, depth);
                var bottom = makeMesh(bsp_bottom, colorMaterials[4]);
                bottom.position.y = -height/6.5;
                car.add(bottom);

                // add train top
                var topGeom = new THREE.BoxGeometry(width*1.015, height/10, depth + 0.01);
                var top = new THREE.Mesh(topGeom, colorMaterials[4]);
                top.position.set(width/2, height, 0);
                car.add(top);

                // add "glass" to windows
                var windowGeom = makeTrainCarGeomUpperBevel(width-0.1, height, depth - 0.1, 0, 0, 0);
                var windowInsideGeom = makeTrainCarGeomUpperBevel(width-0.2, height, depth - 0.2, 0.01, 0, 0);
                windowGeom = windowGeom.subtract(windowInsideGeom); // remove inside of glass prism
                var window = makeMesh(windowGeom, colorMaterials[3]);
                car.add(window);

                // wood
                var interior = makeInterior(width, height, depth - 0.1, colorMaterials[5]);
                interior.position.x = .01;
                car.add(interior);

                // add cylinders on top to decorate
                var smallCyl1 = makeTrainTopCylinder(1.5, .5, colorMaterials[4]);
                var smallCyl2 = makeTrainTopCylinder(1.5, .5, colorMaterials[4]);
                var longCyl = makeTrainTopCylinderLong(2, 1.5, .5, colorMaterials[4]);
                smallCyl1.position.set(width*0.85, height*1.05, 0); // front side of car
                smallCyl2.position.set(width*0.15, height*1.05, 0); // back side of car
                longCyl.position.set(width*0.5, height*1.05, 0); // center of train car x-wise
                car.add(smallCyl1);
                car.add(smallCyl2);
                car.add(longCyl);

                // add train headlight with light beam
                var spotlight = makeSpotlight(.5, colorMaterials[6], colorMaterials[4], 1);
                spotlight.position.set(width-0.25, height-0.25, 0);
                var light = new THREE.SpotLight(0xffffff, 1, 0, TW.degrees2radians(20), 0, 1);
                light.position.set(width, height-0.25, 0);
                light.target.position.set(30, 0, 0);
                car.add(spotlight);
                car.add(light);
                car.add(light.target);

                // add flooring to car
                var floor = makeFloor(width*1.08, depth);
                floor.position.set(width*0.54, 0, 0);
                car.add(floor);

                //add seats to car
                var seat = makeSeatRows(width/2, height/2.25, depth/5, 1.4);
                seat.position.set(width/2, 0, 0);
                car.add(seat);

                return car;
            }

            function makeTrain(){
                var train = new THREE.Object3D();

                var space = params.space;
                // make two base car geometries
                var car1 = makeTrainCar(params.width, params.height, params.depth, colorMaterials[0]);
                var car2 = makeTrainCar(params.width, params.height, params.depth, colorMaterials[0]);
                car1.position.x = space;
                car2.position.x = -space;
                car2.rotation.y = Math.PI;

                train.add(car1);
                train.add(car2);

                wheelSet = makeWheels(params.width, params.height, params.depth, colorMaterials[2]);
                wheelSet.position.y = -params.height/20;
                train.add(wheelSet);

                var connector = addConnector();

                train.add(connector);

                return train;
            }

            //makes one row of seats and returns seat object
            function makeSeat(width, height, depth){

                var seat = new THREE.Object3D();
                
                //makes the bottom of the seat with brown color
                var bottomGeom = new THREE.BoxGeometry(width, height/2, depth);
                var bottomMesh = new THREE.Mesh(bottomGeom, colorMaterials[5]);
                bottomMesh.position.y = height/4;
                bottomMesh.position.z = depth/2;
                seat.add(bottomMesh);

                //makes the side of the seat with brown color
                var sideGeom = new THREE.BoxGeometry(width, height, depth/5);
                var sideMesh = new THREE.Mesh(sideGeom, colorMaterials[5]);
                sideMesh.position.y = (height * 1.5)/2;
                sideMesh.position.z = depth - depth/10;
                seat.add(sideMesh);

                //makes the bottom of the cushion with red color
                var cushionBottomGeom = new THREE.BoxGeometry(width, height/6, depth);
                var cushionBottomMesh = new THREE.Mesh(cushionBottomGeom, colorMaterials[4]);
                cushionBottomMesh.position.y = height/2 + height/12;
                cushionBottomMesh.position.z = depth/2 -depth/5;
                seat.add(cushionBottomMesh);

                //makes the side of the cushion with the red color
                var cushionSideGeom = new THREE.BoxGeometry(width, height/1.5, depth/5);
                var cushionSideMesh = new THREE.Mesh(cushionSideGeom, colorMaterials[4]);
                cushionSideMesh.position.y = height/2 + (height/1.5)/2;
                cushionSideMesh.position.z =  depth -(3 * depth)/10;
                seat.add(cushionSideMesh);

                return seat;
            }

            //creates two rows of seats for the two sides of one train car and return seatRows object
            function makeSeatRows(width, height, depth, space){
                var seatRows = new THREE.Object3D();

                var row1 = makeSeat(width, height, depth);
                var row2 = makeSeat(width, height, depth);

                row2.rotation.y = Math.PI;
                row2.position.z = -space;
                row1.position.z = space;

                seatRows.add(row1);
                seatRows.add(row2)

                return seatRows;

            }

            function makeSign(radius, height){
                var sign = new THREE.Object3D();

                var barGeom = new THREE.CylinderGeometry(radius, radius, height, 32);
                var barMesh = new THREE.Mesh(barGeom, materials[4]);

                var plateGeom = new THREE.CylinderGeometry(radius * 10, radius * 10, radius + .2, 32);
                var plateMesh = new THREE.Mesh(plateGeom, colorMaterials[4]);

                plateMesh.rotation.x = Math.PI/2;
                plateMesh.position.y = height/2;

                sign.add(barMesh);
                sign.add(plateMesh);

                return sign; 

            }

            //creates floor with plane geometry and returns floor object
            function makeFloor(width, height){
                
                var floor = new THREE.Object3D();

                var planeGeom = new THREE.PlaneGeometry(width, height);
                var planeMesh = new THREE.Mesh(planeGeom, materials[7]);

                planeMesh.rotation.x = Math.PI/2;

                floor.add(planeMesh);

                return floor;
            }

            //creates spotlight at the top of the train and returns spotlight object 
            function makeSpotlight(radius, contrastMaterial, cylMaterial, side){

                var spotlight = new THREE.Object3D();

                // make light container
                var cylGeom = new THREE.CylinderGeometry(radius, radius*1.2, radius, 20);
                var cylMesh = new THREE.Mesh(cylGeom, cylMaterial);
                cylMesh.rotation.z = Math.PI/2;
                cylMesh.position.y = radius;
                spotlight.add(cylMesh);

                var sphereGeom = new THREE.SphereGeometry(radius, 32, 16 );
                var sphereMesh = new THREE.Mesh(sphereGeom, cylMaterial);
                sphereMesh.position.y = radius;
                sphereMesh.position.x = -radius/2;
                spotlight.add(sphereMesh);

                var sphereGeom = new THREE.SphereGeometry(radius*1.2, 32, 16 );
                var sphereMesh = new THREE.Mesh(sphereGeom, cylMaterial);
                sphereMesh.position.y = radius;
                sphereMesh.position.x = radius/2;
                spotlight.add(sphereMesh);

                // make light bulb
                var sphereGeom = new THREE.SphereGeometry(radius/2, 32, 16 );
                var sphereMesh = new THREE.Mesh(sphereGeom, colorMaterials[3]);

                sphereMesh.position.x = side * 0.7;
                sphereMesh.position.y = radius;
                spotlight.add(sphereMesh);

                var sphereGeom = new THREE.SphereGeometry(radius/2, 32, 16 );
                var sphereMesh = new THREE.Mesh(sphereGeom, contrastMaterial);

                sphereMesh.position.x = side * 0.65;
                sphereMesh.position.y = radius;
                spotlight.add(sphereMesh);

                return spotlight;
            }

            //creates the circular cylinder decoration at the top of the train and returns cylinder object 
            function makeTrainTopCylinder(radius, height, material){

                var cylinder = new THREE.Object3D();
                
                var cylinderGeom = new THREE.CylinderGeometry(radius, radius, height, 20);
                var cylinderMesh = new THREE.Mesh(cylinderGeom, material);
                cylinderMesh.position.y = height/2;
                cylinder.add(cylinderMesh);

                return cylinder;
            }

            //creates the longer cylinder decoration at the top of the train and returns cylinder object 
            function makeTrainTopCylinderLong(width, radius, height, material){

                var cylinderLong = new THREE.Object3D();

                var cylinder1 = makeTrainTopCylinder(radius, height, material);
                var cylinder2 = makeTrainTopCylinder(radius, height, material);

                cylinder1.position.x = width/2;
                cylinder2.position.x = -width/2;

                var boxGeom = new THREE.BoxGeometry(width, height, radius * 2);
                var boxMesh = new THREE.Mesh(boxGeom, material);
                boxMesh.position.y = height/2;

                cylinderLong.add(boxMesh);
                cylinderLong.add(cylinder1);
                cylinderLong.add(cylinder2);

                return cylinderLong;
            }

            function makeWindowEnds(side){

                var window = new THREE.Object3D();

                var cylinderGeom = new THREE.CylinderGeometry(5, 5, 20, 32);
                // var cylinderGeom = 
            }

            //creates pieces to connect the two train cars and return connector object
            function addConnector(){

                var connector = new THREE.Object3D();

                var space = params.space;
                var width = space * 2 - .01;
                var height = params.height - .5;
                var depth = params.depth - .5;

                var boxGeom = new THREE.BoxGeometry(width, height, depth);
                var boxMesh = new THREE.Mesh(boxGeom, colorMaterials[2]);
                boxMesh.position.y = height/2;

                connector.add(boxMesh);

                return connector;
            }


            // make train station platform
            function makePlatform() {
                // make plane size relative to ground size
                var dimension = params.groundDimension;
                var platHeight = 1.5;

                var platGeom = new THREE.CylinderGeometry( dimension/130, dimension/100, platHeight, 4, 1 );
                platGeom.rotateY( Math.PI / 4 );
                platGeom.scale( 6, 1, 1 );
                // var platGeom = new THREE.BoxGeometry(dimension/50, platHeight, dimension/200);
                var platMesh = new THREE.Mesh(platGeom, materials[1])
                platMesh.position.set(-10, platHeight*0.5, -params.plankDepth*2); // add a little extra on y so it doesn't glitch

                return platMesh;
            }

            // render the scene
            function remakeScene() {
                addLighting();

                var ground = makeGround();
                scene.add(ground);

                var plat = makePlatform();
                scene.add(plat);

                train = makeTrain();
                train.position.y = 1.3;
                // train.position.x = -params.groundDimension/2;
                train.position.x = 0; // for debugging
                scene.add(train);

                var sign = makeSign(.1, 5);
                sign.position.set(-38, 3, -10);
                scene.add(sign);

                // var testbox = createBoxWithRoundedEdges( 2, 2, 2, 5 / 9, 16 );
                // var boxGeom = new THREE.Mesh(testbox, colorMaterials[4]);
                // boxGeom.position.y = 10
                // scene.add(boxGeom);

                render();
            }
            // ====================================================================
            // make lights

            function addLighting() {
                // 55% intensity
                var ambLight = new THREE.AmbientLight(new THREE.Color("white"), 0.55);
                scene.add(ambLight);
                
                // directional light coming from slightly right, front, and up direction
                var dirLight = new THREE.DirectionalLight( TW.WHITE, 0.7 );
                dirLight.position.set( 0.7, 0.9, 1 );
                // dirLight.position.set(0, 5, 10);
                scene.add(dirLight);
            }

            // ====================================================================
            // make camera views

            function showTrainSideView() {
                params.insideTrain = false;
                cameraParams = {
                    near: 1,
                    far: params.groundDimension,
                    fov: 100,
                    aspectRatio: window.innerWidth/window.innerHeight,
                    atX: 0,
                    atY: 5,
                    atZ: 0,
                    eyeX: 0,
                    eyeY: 5,
                    eyeZ: 40,
                    upX: 0,
                    upY: 1,
                    upZ: 0
                };
                camera = setupCamera();
            }

            function followTrainSideView() {
                params.insideTrain = true;
                cameraParams = {
                    near: 1,
                    far: params.groundDimension,
                    fov: 100,
                    aspectRatio: window.innerWidth/window.innerHeight,
                    atX: 0,
                    atY: 5,
                    atZ: -params.groundDimension,
                    eyeX: train.position.x,
                    eyeY: 5,
                    eyeZ: 30,
                    upX: 0,
                    upY: 1,
                    upZ: 0
                };
                camera = setupCamera();
            }


            // function showTrainFrontalView() {
            //     return null;
            // }

            function showInsideTrain() {
                params.insideTrain = true;
                cameraParams = {
                    near: 1,
                    far: params.groundDimension,
                    fov: 100,
                    aspectRatio: window.innerWidth/window.innerHeight,
                    atX: params.groundDimension,
                    atY: 5,
                    atZ: 0,
                    eyeX: train.position.x,
                    eyeY: 4.5,
                    eyeZ: 0,
                    upX: 0,
                    upY: 1,
                    upZ: 0
                };
                camera = setupCamera();
            }
            
            // ====================================================================
            // animation 

            var animationState;

            function resetAnimationState() {
                animationState = {
                    vx: 1.2,
                    rz: 1.2/(params.height/15)
                }
            }
            resetAnimationState();

            function pauseAnimation() {
                animationState.vx = 0;
                animationState.rz = 0;
                params.moving = false;
            }

            function increaseSpeed() {
                animationState.vx += .003;
                animationState.rz += .001;
            }

            function decreaseSpeed() {
                animationState.vx -= .00145;
                animationState.rz -= .0005;
            }

            function oneStep() {
                train.position.x += animationState.vx;
                for (let i = 0; i < wheelList.length; i++) {
                    wheelList[i].rotation.z -= animationState.rz;
                }

                if (params.moving) {
                    if (params.insideTrain) {
                        camera.position.x += animationState.vx;
                    }

                    // restart train at left end
                    if (train.position.x >= params.groundDimension/2-params.width*3) {
                        train.position.x = -params.groundDimension/2 + params.width*3;
                        params.hasStopped = false;
                        resetAnimationState();
                        if (params.insideTrain) {
                            camera.position.x = -params.groundDimension/2 + params.width*3;
                        }
                    }
                    // pause train at the platform
                    else if (train.position.x > -5) {
                        if (!params.hasStopped) {
                            params.hasStopped = true;
                            pauseAnimation();
                            setTimeout(() => { params.moving = true; }, params.wait); // restart animation after wait
                        } else {
                            increaseSpeed();
                        }
                    } else {
                        decreaseSpeed();
                    }
                }
            }

            function animate() {
                // oneStep(); 
                render();
                requestAnimationFrame(animate);
            }

            function render() {
                renderer.render(scene, camera);
            }

            // ====================================================================

        </script>
    </body>
</html>